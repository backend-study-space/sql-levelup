# 서브쿼리가 일으키는 폐해

## 서브쿼리의 문제점

- 서브쿼리의 성능적 문제는 결과적으로 서브쿼리가 실체적인 데이터를 저장하고 있지 않다는 점에서 기인합니다.

### 연산비용 추가
- 그 뜻은, 서브쿼리에 접근할 때마다 SELECT 구문을 실행해서 데이터를 만들어야 한다는 뜻입니다.

- 서브쿼리의 내용이 복잡하면 복잡할수록 실행 비용이 더 높아집니다.

### 데이터 I/O 비용 발생
- 연산 결과는 어딘가에 저장해두어야합니다. 버퍼 메모리가 충분하다면 오버헤드가 적겠지만, 버퍼 메모리가 초과되면 디스크 접근으로 인한 속도 저하가 심각해질 수 있습니다.

### 최적화 불가능
- 서브쿼리로 만들어지는 데이터는 구조적으로 테이블과 차이가 없지만, 명시적 제약 또는 인덱스가 작성되어 있는 테이블과 달리, 서브쿼리에는 그런 메타 정보가 존재하지 않습니다.

- 그렇기 때문에, SQL을 작성할 때 서브쿼리를 꼭 작성해야 하는 것인지 유의하며 작성해야합니다.

## 서브쿼리 의존증

| cust_id(고객 ID) | seq(순번) | price(구입 가격) |
|------------------|-----------|------------------|
| A                | 1         | 500              |
| A                | 2         | 1000             |
| A                | 3         | 700              |
| B                | 5         | 100              |
| B                | 6         | 5000             |
| B                | 7         | 600              |
| C                | 20        | 200              |
| C                | 3         | 150              |

이 테이블에서 각 고객이 구입한 순번이 가장 낮은(오래된) 상품의 구입 가격을 구해야하는 상황이 있다고 가정봅시다.

-  서브쿼리를 이용한 SQL은 다음과 같습니다.

    ```Postgresql
    SELECT R1.cust_id, R1.seq, R1.price
        FROM Receipts R1
            INNER JOIN
                (SELECT cust_id, MIN(seq) AS min_seq
                    FROM Receipts
                GROUP BY cust_id) R2
        ON R1.cust_id = R2.cust_id
    AND R1.seq = R2.min_seq;
    ```

    - 서브쿼리를 사용한 방법에는 코드가 복잡하다는 단점 이외에도, 성능적으로 문제가 되는 부분이 있습니다.
        1. 서브쿼리는 대부분 버퍼 혹은 디스크에 확보되므로 오버헤드가 생깁니다.
        2. 서브쿼리는 인덱스 등의 정보를 가지지 않기 때문에 최적화가 불가능합니다.
        3. 결합이 이뤄지기 때문에 비용이 높고 실행 계획 변동 리스크가 있습니다.
        4. 테이블 풀 스캔이 2회 이뤄집니다.

- 윈도우 함수를 사용한 SQL은 다음과 같습니다.

    ```Postgresql
    SELECT cust_id, seq, price
	FROM (SELECT cust_id, seq, price,
    	ROW_NUMBER()
        	OVER (PARTITION BY cust_id
            			ORDER BY seq) AS row_seq
           FROM Receipts ) WORK
    WHERE WORK.row_seq = 1;
    ```

    - ROW_NUMBER를 사용해 사용자의 구매 이력에 추가적인 번호를 보여해, 가장 낮은 seq를 가진 항목만 필터를 걸어서 조회하는 방법을 사용했습니다.

    - 이 방법을 통해 테이블 풀 스캔을 1회로 줄였습니다.
    - 또한, 테이블 결합을 없애 실행계획 변동에 의해 효율성에 차질이 생기는 경우를 미연에 방지했습니다.