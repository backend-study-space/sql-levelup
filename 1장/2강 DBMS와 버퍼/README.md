# DBMS와 버퍼

## 버퍼의 주요 기능과 역할

### 디스크 I/O 최소화: 
- 데이터베이스 시스템은 데이터를 디스크에서 직접 읽고 쓰는 대신, 버퍼를 통해 작업을 수행합니다. 이는 디스크 작업이 메모리 작업보다 훨씬 느리기 때문에 중요합니다. 버퍼를 사용함으로써 반복적인 디스크 액세스를 줄이고, 성능을 향상시킬 수 있습니다.

### 데이터 캐싱: 

- 자주 사용되는 데이터는 버퍼에 저장되어, 후속 데이터 요청 시 빠르게 제공될 수 있습니다. 이는 데이터베이스 시스템의 응답 시간을 단축시키는 데 도움이 됩니다.

### 쓰기 지연 (Write-back or Delayed Write): 
- 데이터를 디스크에 즉시 쓰는 것이 아니라, 버퍼에 일정 시간 동안 저장해두고, 조건이 충족될 때(예: 버퍼가 가득 찼을 때, 정해진 시간 간격 등)에 디스크에 쓰기를 수행합니다. 이는 쓰기 작업의 효율성을 높여줍니다.

### 트랜잭션 관리 및 복구: 
- 버퍼는 트랜잭션이 수행되는 동안 변경된 데이터를 임시로 저장하는 역할도 합니다. 이를 통해 시스템이 실패했을 경우, 버퍼에 저장된 정보를 사용하여 데이터베이스를 이전 상태로 복구할 수 있습니다.

## 메모리 위에 있는 두 개의 버퍼

### 데이터 캐시

- PostgreSql에서는 'Shared Buffers' 라고 불리는데, 서버가 디스크에서 읽은 데이터 블록을 메모리에 저장하는 공간입니다. 동일한 데이터의 반복적인 요청이 있을 경우 디스크에 접근하는 것이 아니라, 메모리에 저장된 데이터를 반환시켜 처리시간을 단축시킵니다. shared_buffers 설정을 통해 공간의 크기를 할당할 수 있습니다.

### 로그 버퍼

- 로그 버퍼는 갱신처리(CUD 작업)과 관련이 있습니다. 갱신 SQL을 받았을 때, 곧바로 디스크에 기록하지 않고 로그 버퍼에 변경 정보를 기록한 후, 이후에 디스크에 기록 됩니다. 이러한 방법을 사용하는 이유는 성능을 높이기 위해서인데, 갱신 SQL 구문 삽입 후 동기적으로 갱신이 끝날 때 까지 기다리게되면 상당한 시간이 소모됩니다. 그렇기 때문에 비동기로 SQL 삽입과 동시에 결과를 반환받고, 내부적으로 관련 처리를 수행합니다.

## 트레이드 오프

### 메모리의 성질이 초래하는 트레이드 오프

#### 휘발성 : 

- 메모리의 데이터는 영속성이 없습니다. 하드웨어의 전원이 꺼지면 메모리에 올라가있는 데이터 또한 함께 휘발됩니다. 마찬가지로, DBMS를 껐다 키면 버퍼 위의 모든 데이터가 삭제됩니다.

#### 문제점 :
- 그렇다면 로그 버퍼 위에 존재하는 데이터가 디스크로 반영되기 전에 DBMS 서버에 문제가 생겨 다운된다면 사용자가 수행했던 갱신 정보가 삭제되고, 정합성에 문제가 생깁니다. 예를들어 은행 입출금 상황에서 문제가 발생한다면 정말 큰일이 발생할 것 입니다.

#### 해결 :
- 따라서 이를 해결하고자, DBMS는 commit 시점에 반드시 디스크에 데이터를 영속화 함으로써, 장애가 발생해도 정합성을 유지시킬 수 있게 합니다.

### 시스템 특성에 따른 트레이드오프

데이터 캐시와 로그 버퍼의 크기는 DBMS에서 어떻게 할당하면 좋을지는, 시스템의 특성에 따라 다릅니다.

일반적인 서버 어플리케이션의 경우 특정 시간대에 진행되는 배치 작업 등의 경우를 제외한다면 쓰기 작업에 비해 읽기 작업이 훨씬 많습니다.

이런 경우, 검색 처리를 할 때는 검색 대상 레코드가 수백 ~ 수천 만 건에 달하는 경우도 많습니다. 반면, 갱신 처리를 할 때에는 대상이 많아봤자 한 건 ~ 수만 건 정도밖에 안됩니다.

그렇기 때문에, 대부분의 RDBMS의 경우 데이터 캐시의 용량을 로그 버퍼보다 훨씬 큰 값으로 초기화합니다.

만약 어플리케이션이 갱신이 많다면 로그 버퍼의 크기를 늘려주는 튜닝을 고려해봐야 할 것입니다.

## 워킹 메모리

### 워킹 메모리란
- RDBMS에서는 앞서 두 개의 버퍼 이외에도, 정렬, 해서 처리 등의 작업을 수행하는 <b>워킹 메모리</b> 라는 영역을 가지고있습니다.

- PostgreSql 에서는 '워크 버퍼' 라는 명칭을 가지고 있으며, 성능적으로 매우 중요한 영역입니다.

### 성능적으로 중요한 이유
- 이 영역이 다루려는 데이터양보다 작아서 문제가 생기게되면, 디스크로 접근해 계산하게됩니다. OS 동작에서 말하는 스왑(swap)과 같은 과정입니다.

- DBMS는 워킹 메모리가 부족할 때 사용하는 임시 영역을 가지고 있는데, PostgreSql에서는 'pgsql_tmp' 라고 부릅니다.

### 부족하면 생기는 일
- 저장소는 메모리에 비해 굉장히 느립니다. 따라서 워킹 메모리 부족으로 인해 디스크의 임시영역에 접근해서 계산하게 되면 전체적인 속도가 매우 감소하게됩니다.

- 물론 자바 처럼 OOM 에러가 발생해 모든 작업이 멈추는 것 보다, 속도가 조금 느리더라도 에러가 발생하진 않습니다.

- SQL 구문들이 공유해서 사용하기 때문에, 특정 SQL이 많이 접근하는 시간대 등의 환경에 따라서 달라지기 때문에 재현하기가 까다로운 점이 있습니다.